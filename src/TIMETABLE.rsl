NET
scheme TIMETABLE = extend NET with
class
	type
	    TimeTable = TramId -m-> TimeSlot-list, -- time tables
	    TimeSlot = StopId >< Time >< Time,	-- stopId, arrival, departure
	    TramId = Text -- tram names

    value /* generators */
		-- the empty timetable
		empty: TimeTable = [],
		
		-- add an empty plan for a new tram to time table
		addTram: TramId >< TimeTable -> TimeTable
		addTram(id, table) is table !! [id +> <..>],
		
		-- add a stop with arrival time and departure time to the plan for a given tram
		addStop: TramId >< StopId >< Time >< Time >< TimeTable -> TimeTable
		addStop(tId, sId, arrival, depature, table) is 
			if table(tId) = <..> then
				let 
					plan = table(tId) 
				in 
					table !! [tId +> <.(sId, arrival, depature).>]
				end
			else
				let 
					plan = table(tId),
					newPlan = plan ^ <.(sId, arrival, depature).> 
				in 
					table !! [tId +> newPlan] 
				end
			end
 
	value /* observers */
		-- check whether a tram with a given name exists in a given time table
		isIn : TramId >< TimeTable -> Bool
		isIn(id, table) is id isin dom table

     -- you can add more observers here
 
  value /* predicates to check time tables */   
		isWellformed : TimeTable >< Net -> Bool
		isWellformed(table, net) is checkTramTimeTable(table, net) /\ isNotEmpty(table) /\ getTrams(table, net),
		
		-- checks that every stop in the time table exists in the tram net
		checkTramTimeTable: TimeTable >< Net -> Bool
		checkTramTimeTable(table, net) is
			let
				(stops, connection) = net				
			in
				(all tramId : TramId :- tramId isin table =>
					let 
						stops = table(tramId)
					in
						(all (s, dep, arr) : StopId >< Time >< Time :- (s, dep, arr) isin stops =>
							(exists (s1, s2) : StopId >< StopId :- (s1, s2) isin connection /\
								(s = s1 \/ s = s2))
						)
					end
				)
			end,
		
		-- checks that the TimeTable doesn't have empty lists
		isNotEmpty : TimeTable -> Bool
		isNotEmpty(table) is 
			(all tramId : TramId :- tramId isin table => 
				if table(tramId) = <..> then
					false
				else
					true
				end
			),
		
		-- goes through all trams
		getTrams : TimeTable >< Net -> Bool
		getTrams(table, net) is
			(all tram : TramId :- tram isin table => checkMinDrivingTime(table(tram), net)),
			/*
			let
				tram1 = hd dom table,
				tram2 = hd dom (table \ {tram1})
			in
				(table(tram1), net)
			end,
			*/
		-- checks that the 
		checkMinDrivingTime : TimeSlot-list >< Net -> Bool
		checkMinDrivingTime(tram1, net) is 
		if tram1 ~= <..> then
			if tl tram1 = <..> then
				true
			else
				let
					(id1, arr1, dep1) = hd tram1,
					(id2, arr2, dep2) = hd tl tram1,
					(ztop, connection) = net,
					(head, cap, drive) = connection(id1, id2),
					dt = arr2 - dep1
				in
					if dt < drive then
						false
					else
						checkMinDrivingTime(tl tl tram1, net)
					end
				end
			end
		else
			 true
		end,
		
		checkForSameConnection : TimeSlot-list >< TimeTable >< Net -> Bool
		checkForSameConnection(tram1, table, net) is true
		
		-- TODO:
		-- Trams using same connection at same time <= capacity
		-- Trams using same connection, check that the time corresponds to the headway
		-- Time table has proper connections (e.g. a -> c or a -> a would not be possible)

end  
